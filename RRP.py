# -*- coding: utf-8 -*-
#-------------------------------------------------------------------------------
# Name:        RRP
# Purpose:
#
# Author:      g.ukryukov
#
# Created:     10.07.2018
# Copyright:   (c) g.ukryukov 2018
# Licence:     <your licence>
#-------------------------------------------------------------------------------
import math

def f1(l, b, alf3, dks):
    by = 1.2 * alf3 * l**2
    r = 2 * math.sqrt(by)
    px = b/l * math.sqrt(by * (1.5 - 1/(1 + math.sinh(r)/r)))
    dkss = dks/b
    kx = 2 * math.sinh(px * dkss) * math.cosh(0.5 * px)/math.sinh(px)
    fi = kx * math.cosh(0.5 * px) - math.cosh(px * dkss) + 1
    return fi

def nki(a, n):
    T = [1, 2, 5, 10, 15, 20, 30, 40, 50]
    B3 = [1.9, 1.7, 1.44, 1.28, 1.18, 1.13, 1.05, 1.02, 1]
    n1 = n - 1
    for i in range(n1):
        if(a >= T[i])and(a <= T[i+1]):
            b = B3[i] - (B3[i] - B3[i+1])*(a-T[i])/(T[i+1] - T[i])
        else:
            b = 1
    return b

def d_ekv(dell, h1):
    """
    Возвращает эквивалентный диаметр для течения среды в каналах рёбер
    dell - половина расстояния между рёбрами, h1 - высота ребра
    На выходе Real
    """
    fj = 2 * dell * h1       # площадь канала между рёбрами
    u = 2 * (h1 + 2 * dell)  # периметр канала между рёбрами
    dk = 4 * fj / u
    return dk

def edge_par(b, l, br, s, h1, h0, fr1):
    """
    Возвращает параметры радиатора на основании исходных данных
    b, l - ширина радиатора и длина ребра, br - толщина ребра, s - расстояние между рёбер
    h1 - высота ребра, h0 - толщина основания,
    fr1 - боковая поверхность рёбер, изымаемая при выборке
    на выходе
    dell - половина расстояния между рёбер, fr - боковая поверхность рёбер,
    f0 - поверхность радиатора без боковых рёберных поверхностей, fp - полная поверхность основания
    """
    nz = (b - br)/s + 1          # количество рёбер
    fp = l * b                   # полная площадь поверхности основания
    dell = (s - br)/2            # половина расстояния между рёбрами
    fr = 2 * (nz - 1) * h1 * l - fr1      # Боковая поверхность рёбер, исключая часть из выборки

    if fr <= 0:                         # Допускается установка ППП на поверхность, меньше контактной
        fr = 0

    f0 = 2*(h1 + h0)*l + 2*nz*h1*br  + br*nz*l + 2*b*h0 + (nz-1)*l*2*dell   # Поверхность радиатора без боковых поверхностей рёбер
    return dell, fr, f0, fp

def number_Re(w, d):
    """
    Число рейнольдса, w - скорость потока, d - определяющий размер
    """
    return 55710.3 * w * d

def number_Nu_force(re, q):
    """
    Число Нуссельта для принудительной конвекции. re - число Рейнольдса,
    l - определяющий размер, q - отношение длины канала к "калибру"
    На выходе Real.
    """
    if re <= 2200:
        a = 0.7*re/q
        if a <= 5:
            nu = 9
        elif a <= 100:
            nu = 8.4*a**0.045
        else:
            nu = 2.32*a**0.33
    else:
        fl = nki(q, 9)    # ????
        if (q <= 50):
            nu = fl*0.0216*re**0.8
        else:
            nu = 0.0216*re**0.8
    return nu

def number_Nu_force_2(re):
    """
    Число Нуссельта для принудительной конвекции для плоскости.
    re - число Рейнольдса
    На выходе Real
    """
    if re >= 1E5:
        nu = 0.084*re**0.8
    else:
        nu = 0.792*re**0.5
    return nu

def number_Alfa_radiation(t_air, dt_max, dell, h1):
    """
    Коэффициент лучистой теплоотдачи. tb - температура среды,
    dt_max (dtr) максимально допустимая разница температур (среда-элемент)
    dell - половина расстояния между рёбер
    h1 - высота ребра
    На выходе: alfl - с плоской стороны, alflr - с ребристой
    """
    tr = t_air + dt_max               # Температура поверхности радиатора
    fi1 = dell/(h1 + dell)              # Безразмерный параметр хз чего. Половина расстояния между рёбрами, делёная на сумму высоты и половину расстояния.
    alfl = 4.5E-8 * ((tr + 273)**4 - (t_air + 273)**4)/dt_max    # Теплообмен излучением с воздухом через постоянную Больцмана. Зачем делим на Дтр?
    alflr = alfl * fi1                          # Получаем альфу лучистую
    return alfl, alflr

def number_Alfa(nu, l, t = 50):
    """
    nu - число Нуссельта, l - определяющий размер
    Коэффициент теплоотдачи для воздуха. Теплопроводность взята при Т=50
    """
    # Дописать расчёт теплопроводности воздуха
    alfa = 0.0283 * nu/l
    return alfa

def get_real(message, name="real",default=None):

    class RangeError(Exception): pass
    message += ": " if default is None else " [{0}]: ".format(default)
    while True:
        try:
            line = input(message)
            if not line and default is not None:
                return default
            i = float(line)
            if i >= 0:
                return i
            else:
                raise RangeError("{0} may not be 0".format(name))
            return i
        except RangeError as err:
            print("ERROR", err)
        except ValueError as err:
            print("ERROR {0} must be an real".format(name))


def main():
    L1 = [3.6E-2, 3.6E-2, 5E-2, 5E-2, 5E-2, 8E-2, 8E-2, 8E-2, 1E-1, 1E-1, 1E-1,
            1.25E-1, 1.25E-1, 1.25E-1]
    B1 = [3.2E-2, 7.2E-2, 3.2E-2, 5.2E-2, 9.2E-2, 3.2E-2, 7.2E-2, 1.22E-1,
            5.2E-2, 9.2E-2, 1.52E-1, 7.2E-2, 1.22E-1, 1.52E-1]
    L2 = [5E-2, 5E-2, 8E-2, 8E-2, 1E-1, 1E-1, 1E-1, 1.25E-1,  1.25E-1,  1.25E-1]
    B2 = [5.2E-2, 9.2E-2, 7.2E-2, 1.22E-1, 5.2E-2, 9.2E-2, 1.52E-1, 7.2E-2, 1.22E-1, 1.52E-1]
    SV = [0.02, 0.045, 0.08, 0.125, 0.180, 0.245]

    tb = get_real("Введите температуру воздуха, °C", default = 65)
    h1 = get_real("введите высоту ребра, м", default = 0.020)
    lm = get_real("максимально допустимая высота радиатора, м", default = 0.125)
    bm = get_real("максимально допустимая ширина радиатора, м", default = 0.152)
    w = get_real("Скорость потока среды, м/с", default = 1)                                     # Единственный новый параметр
    k = get_real("Односторонний или двусторонний радиатор (1/2) ", default = 1)
    n = int(get_real("Количество ППП, установленных на радиаторе", default = 1))
    k1 = get_real("Имеется ли выборка (0/1)", default = 0)
    pi = list()
    k2 = list(); kkr = list(); tdop = list(); s0 = list()
    for i in range(n):
        temp = get_real("Мощность элемента {0}, Вт".format(i), default = 7.5)
        pi.append(temp)
        temp = get_real("Максимально допустимая температура элемента {0}, °С".format(i), default = 105)
        tdop.append(temp)
        temp = get_real("Площадь контакта элемента {0}, м2".format(i), default = 543E-6)
        s0.append(temp)
        temp = get_real("Удельное контактное тепловое сопротивление элемента {0} м2*К/Вт".format(i), default = 0.76E-4)
        kkr.append(temp)
        temp = get_real("Признак выборки под ППП {0} (1..6)".format(i), default = 5)
        k2.append(temp)

    s = 0.005
    br = 0.001
    h0 = 0.005
    dks = math.sqrt(s0[0]/3.14)  #почему? Иди нахуй. вот почему.
    p = 0
    dtoop = 1000    # допустимый перегрев
    fr1 = 0
# ---------------------
    for i in range(n):
        kk = int(k2[i])                  # здесь хранится номер выборки i-того элемента
        p = sum(pi)                 # здесь собираем суммарную мощность ППП
        fr1 = fr1 + 2 * SV[kk] * h1 * k1
        tdop[i] -= tb - pi[i] * kkr[i] / s0[i]  # расчёт допустимого перегрева (минимального)
        if(tdop[i] <= dtoop):
            dtoop = tdop[i]
# --------------------
    pr = p*0.7

    for i in range(14):
# Здесь подбирается радиатор из сетки размеров для одной и двх сторон
#        print(" - - - - -Вариация {0} - - - - - ".format(i))
        if k == 1:
            l = L1[i]
            b = B1[i]
        else:
            l = L2[i]
            b = B2[i]
#        print("L = {0}; B = {1};".format(l, b))
# ------------------------------------------------------------------
# Если радиатор из списка больше допустимого размера, значит подборки нет
        if (l > lm) or (b > bm):
            print("Финита ля комедия. Радиаторов не существует. Это фантастика")
            break
# ------------------------------------------------------------------
        dell, fr, f0, fp = edge_par(b, l, br, s, h1, h0, fr1) # параметры радиатора

        dk = d_ekv(dell, h1)                # Гидравлический диаметр
        q = l/dk                    # Отношение длины канала к калибру

        wr = w * s / (s - br)           # ???
        dtb = (0.9E-3 * pr)/(w * (2 * dell * h1))    # ????

        rer = number_Re(wr, dk)
# ----------- Хитрый Нуссельт ---------------------
        nur = number_Nu_force(rer, q)
# ------------ Посчитан хитрый Нуссельт ------------

        dtrr = pr / (number_Alfa(nur, dk) * fr)         #  перегрев при текущей альфа и площади  (может внезапно стать бесконечностью)
        mh1 = 0.15 * math.sqrt(number_Alfa(nur, dk) / br) * h1     # очень похоже на коэффициент эффективности, но не понятно, откуда 0.15
        z = math.tanh(mh1)/mh1              # ----//-----
        dtr = dtrr/z + dtb/2                #???? О_о

        re = number_Re(w, l)
# ----- Хитрый нуссельт для плоской поверхности? -----
        nu_plane = number_Nu_force_2(re)
# ----------------------------------------------------

        p0 = number_Alfa(nu_plane, l) * f0 * dtr                   # Мощность с этой поверхности
# ------- теплообмен излучением ---------
        alfl, alflr = number_Alfa_radiation(tb, dtr, dell, h1)

        plr = alflr*dtr*fr                      # Альфа с поправкой для рёбер
        pl0 = alfl*f0*dtr                       # Плоская часть с боков. Альфа как для плоской

        p2 = pr + p0 + pl0 + plr               # Сумма мощностей. Рёбра конвекция + Рёбра лучистая + поверхность конвекция + поверхность лучистая

        if k == 1:                       # Если односторонинй радик, то мощность как плоская
            pp = number_Alfa(nu_plane, l)*fp*dtr
            plp = alfl*fp*dtr                   # Альфа для плоской части
            p1 = pp + plp
        else:                               # Если двусторонний, то копируем.
            p1 = p2

        alff = (p1 + p2)/(fp*dtr)           # Суммарная альфа
        fix = f1(l/n, b, alff, dks)         # Это за гранью моего понимания. Возможно, растекание тепла по основанию.
        fiy = f1(b, l/n, alff, dks)
        bet = fp/(4*n*dks**2) * fix * fiy       # Какой-то коэффициент растекания
        pp = fp * alff * dtoop/bet
        print("PP : {0}; alff : {1}, w : {2}, wr : {3}".format(pp, alff, w, wr))
        if pp >= p:
            print("Параметры радиатора: длина {0}, ширина {1}, выота ребра {2}".format(l,b,h1))
            break


if __name__ == '__main__':
    main()
